<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>php on Aleksandr Zubarev</title><link>https://zualex.com/tags/php/</link><description>Recent content in php on Aleksandr Zubarev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 27 Apr 2021 14:14:23 +0300</lastBuildDate><atom:link href="https://zualex.com/tags/php/index.xml" rel="self" type="application/rss+xml"/><item><title>Copy-on-write в PHP</title><link>https://zualex.com/posts/copy-on-write-php/</link><pubDate>Tue, 27 Apr 2021 14:14:23 +0300</pubDate><guid>https://zualex.com/posts/copy-on-write-php/</guid><description>Copy-on-write или копирование при записи — один из способов управлением памятью. Но перед тем как давать какие-то определения, предлагаю рассмотреть пример:
function handle(array $array) { $result = []; // ... return $result; } $largeArray = getLargeArray(); handle($largeArray); В данном примере есть функция handle. В эту функцию передаётся массив большого размера. По умолчанию в PHP передача аргументов происходит по значению. Это означает, что если изменить значение аргумента внутри функции, то вне функции значение всё равно останется прежним.</description></item><item><title>PHP производительность array_merge в цикле</title><link>https://zualex.com/posts/php-array_merge-performance-in-a-loop/</link><pubDate>Wed, 24 Mar 2021 11:47:29 +0300</pubDate><guid>https://zualex.com/posts/php-array_merge-performance-in-a-loop/</guid><description>Если использовать array_merge в цикле, то phpStrom + плагин Php Inspections (EA Extended) даёт подсказку: [EA] 'array_merge(...)' is used in a loop and is a resources greedy construction. Стало интересно, насколько сильно влияет на произовдительность использование array_merge в цикле и какие есть альтернативные решения.
Рассмотрим пример. Имеется список товаров следующей структуры:
$products = [ ['id' =&amp;gt; 1, 'tags' =&amp;gt; ['tag_1', 'tag_2', 'tag_3']], ['id' =&amp;gt; 2, 'tags' =&amp;gt; ['tag_1', 'tag_2', 'tag_3']], ]; Нужно получить список всех тегов.</description></item></channel></rss>